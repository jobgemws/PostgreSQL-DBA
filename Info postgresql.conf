Shared_buffers - определяет сколько ОЗУ использовать под кеши постгргерса, имеет смысл поставить около 40% озу, больше ставить не стоит т.к. Postgres также используе PageCache ОС и эффект будет малозаметен. Внимание если используется Postgres ниже 9.2, то для увеличения этого параметра также необходимо увеличить параметр SHMAX ядра

Effective_cache_size - Ождаемый общий объем кеша, нужен для внутренних расчетов постгреса. Мануал рекомендует посмотреть командой free размер PageCache'a , приплюсовать его к объему свободной ОЗУ и это значение указать как Effective_cache_size

checkpoint_segments - Postgresql перед тем как записать файлы в базу, пишет их в предварительные лог файлы WAL(write ahead log), каждый такой файл (сегмент) весит 16 МБ

данный параметр определяет сколько нужно собрать файлов WAL перед тем как осуществить запись в базу (CheckPointing), на высоконагруженные системы рекомендуется ставить это значение в промежутке от 32 (checkpoint каждые 512MB) до 256 (каждые 4GB). Чем больше это значение, тем меньше реже и меньше нагрузки на IO , но больше на время восстановления базы после сбоя.

update:

В версии 9.5 этот параметр заменен параметрами min_wal_size и max_wal_size, и типа нужный размер WAL записываемый в базу будет эффективно вычисляться автоматически

max_worker_processes - задаёт максимальное число фоновых процессов, которое можно запустить в текущей системе. Этот параметр можно задать только при запуске сервера. Значение по умолчанию — 8.

Для ведомого сервера значение этого параметра должно быть больше или равно значению на ведущем. В противном случае на ведомом сервере не будут разрешены запросы.

Одновременно с изменением этого значения также может быть полезно изменить max_parallel_workers, max_parallel_maintenance_workers и max_parallel_workers_per_gather.

max_parallel_workers - Задаёт максимальное число рабочих процессов, которое система сможет поддерживать для параллельных операций. Значение по умолчанию — 8. При увеличении или уменьшения этого значения также может иметь смысл скорректировать max_parallel_maintenance_workers и max_parallel_workers_per_gather. Заметьте, что значение данного параметра, превышающее max_worker_processes, не будет действовать, так как параллельные рабочие процессы берутся из пула рабочих процессов, ограничиваемого этим параметром.

max_wal_size - максимальный размер, до которого может вырасти WAL до наступления автоматической записи лога в базу (checkpointing).

Это мягкий лимит, в специальных случаях пострес может его превысить.

В официальном мануале указана формула расчета max_wal_size, если до этого был настроен параметр checkpoint_segments

max_wal_size = (3 * checkpoint_segments) * 16 MB

min_wal_size - Минимальный размер WAL, необходимый для записи в базу (checkpointing). Пока WAL не вырастет до этого размера, в базу он записан не будет. Увеличение этого параметра может использоваться для резервирования пространства WAL на случай пиков записи вызванных, например, каким-нибудь пакетным заданием. То есть, иначе говоря, увеличение этого параметра позволяет обезопаситься от случая, когда авторегулировка размера WAL не справится с резко прыгающей нагрузкой на WAL.

max_wal_size и min_wal_size должны быть выставлены равными, для отключения авторегулировки

checkpoint_timeout - время между записью чекпоинтов в базу, значение по умолчанию - 5 минут, можно выставить больше - будет меньше нагрузки на IO , но больше на время восстановления базы после сбоя.

checkpoint_completion_target - Запись чекпоинта в базу размазана во времени, чтобы не нагружать IO , этот параметр задает каким образом рассчитывать нагрузку на IO.

Например со значением по умолчанию 0,5 расчет будет производиться так чтобы закончить запись чекпоинта в базу за половину времени checkpoint_timeout, то есть за 2.5 минуты, как обычно можно выставить больше - будет меньше нагрузки на IO, но больше на время восстановления базы после сбоя.

synchronous_commit - Сообщать об успешном завершении транзакции только когда танзакция, помещеная в WAL, запишется на из PageCache в HDD, отключение этого параметра значительно повышает производительность, но понижает надежность. При потере питания поледние транзакции могут не записаться, если это не критично, то можно включить.

work_mem - задаёт максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — четыре мегабайта (4MB). Заметьте, что в сложных запросах одновременно могут выполняться несколько операций сортировки или хеширования, так что этот объём памяти будет доступен для каждой операции. Кроме того, такие операции могут выполняться одновременно в разных сеансах. Таким образом, общий объём памяти может многократно превосходить значение work_mem; это следует учитывать, выбирая подходящее значение. Операции сортировки используются для ORDER BY, DISTINCT и соединений слиянием. Хеш-таблицы используются при соединениях и агрегировании по хешу, а также обработке подзапросов IN с применением хеша.

maintenance_work_mem - задаёт максимальный объём памяти для операций обслуживания БД, в частности VACUUM, CREATE INDEX и ALTER TABLE ADD FOREIGN KEY. Если это значение задаётся без единиц измерения, оно считается заданным в килобайтах. Значение по умолчанию — 64 мегабайта (64MB). Так как в один момент времени в сеансе может выполняться только одна такая операция и обычно они не запускаются параллельно, это значение вполне может быть гораздо больше work_mem. Увеличение этого значения может привести к ускорению операций очистки и восстановления БД из копии.

Учтите, что когда выполняется автоочистка, этот объём может быть выделен autovacuum_max_workers раз, поэтому не стоит устанавливать значение по умолчанию слишком большим. Возможно, будет лучше управлять объёмом памяти для автоочистки отдельно, изменяя autovacuum_work_mem

old_snapshot_threshold - задаёт минимальное время, в течение которого можно пользоваться снимком состояния для запроса без риска получить ошибку снимок слишком стар. Данные, потерявшие актуальность и пребывающие в этом состоянии дольше заданного времени, могут быть вычищены. Это предотвращает замусоривание данными снимков, которые остаются задействованными долгое время. Во избежание получения некорректных результатов из-за очистки данных, которые должны были бы наблюдаться в таком снимке, клиенту будет выдана ошибка, если возраст снимка превысит заданный предел и из этого снимка будет запрошена страница, изменённая со времени его создания.

Если это значение задаётся без единиц измерения, оно считается заданным в минутах. Значение -1 (по умолчанию) отключает это поведение, фактически делая предельный срок снимков бесконечным. Этот параметр можно задать только при запуске сервера.

Изначально надо поставить 1d.

random_page_cost - задаёт приблизительную стоимость чтения одной произвольной страницы с диска (для SSD рекомендуется начать с 1, а с HDD-с 4)

track_io_timing - позволяет посмотреть blk_read_time и blk_write_time в системном представлении pg_stat_database. Эти поля хранят значения-сколько времени уходит на операции чтения и записи (в виртуальных средах не рекомендуется включать, т к накладные расходы в среднем составляют 1 мсек против 100 нс в физическом сервере (/usr/lib/postgresql/12/bin/pg_test_timing)

shared_preload_libraries - список разделяемых библиотек (добавить сюда pg_stat_statements)

max_parallel_maintenance_workers - Задаёт максимальное число рабочих процессов, которые могут запускаться одной служебной командой. В настоящее время параллельные процессы может использовать только одна служебная команда, CREATE INDEX, и только при построении индекса-B-дерева. Параллельные рабочие процессы берутся из пула процессов, контролируемого параметром max_worker_processes, в количестве, ограничиваемом значением max_parallel_workers. Учтите, что запрошенное количество рабочих процессов может быть недоступно во время выполнения. В этом случае служебная операция будет выполняться с меньшим числом процессов, чем ожидалось. Значение по умолчанию — 2. Значение 0 отключает использование параллельных исполнителей служебными командами.

Заметьте, что параллельно выполняемые служебные команды не должны потреблять значительно больше памяти, чем равнозначные непараллельные операции. Это отличает их от параллельных запросов, при выполнении которых ограничения ресурсов действуют на отдельные рабочие процессы. Для параллельных служебных команд ограничение ресурсов maintenance_work_mem считается действующим на команду в целом, вне зависимости от числа параллельных рабочих процессов. Тем не менее, параллельные служебные команды могут гораздо больше нагружать процессор и каналы ввода/вывода

max_parallel_workers_per_gather - Задаёт максимальное число рабочих процессов, которые могут запускаться одним узлом Gather или Gather Merge. Параллельные рабочие процессы берутся из пула процессов, контролируемого параметром max_worker_processes, в количестве, ограничиваемом значением max_parallel_workers. Учтите, что запрошенное количество рабочих процессов может быть недоступно во время выполнения. В этом случае план будет выполняться с меньшим числом процессов, что может быть неэффективно. Значение по умолчанию — 2. Значение 0 отключает параллельное выполнение запросов.

Учтите, что параллельные запросы могут потреблять значительно больше ресурсов, чем не параллельные, так как каждый рабочий процесс является отдельным процессом и оказывает на систему примерно такое же влияние, как дополнительный пользовательский сеанс. Это следует учитывать, выбирая значение этого параметра, а также настраивая другие параметры, управляющие использованием ресурсов, например work_mem. Ограничения ресурсов, такие как work_mem, применяются к каждому рабочему процессу отдельно, что означает, что общая нагрузка для всех процессов может оказаться гораздо больше, чем при обычном использовании одного процесса. Например, параллельный запрос, задействующий 4 рабочих процесса, может использовать в 5 раз больше времени процессора, объёма памяти, ввода/вывода и т. д., по сравнению с запросом, не задействующим рабочие процессы вовсе.

min_parallel_table_scan_size - Задаёт минимальный объём данных таблицы, подлежащий сканированию, при котором может применяться параллельное сканирование. Для параллельного последовательного сканирования объём сканируемых данных всегда равняется размеру таблицы, но когда используются индексы, этот объём обычно меньше. Если это значение задаётся без единиц измерения, оно считается заданным в блоках (размер которых равен BLCKSZ байт, обычно это 8 КБ). Значение по умолчанию — 8 мегабайт (8MB).

parallel_tuple_cost - задаёт приблизительную стоимость передачи одного кортежа от параллельного рабочего процесса другому процессу. Значение по умолчанию — 0.1

track_activity_query_size - задает размер в байтах для хранения текста запроса в поле query системного представления pg_stat_statements (лучше выставить 16 384 или другое значение при необходимости)

log_destination - определяет куда записывать журнал ('stderr'- по умолчанию в Unix-системе, 'csvlog', 'syslog', 'eventlog'-по умолчанию в ОС Windows)

logging_collector - сборщик сообщений (должен быть равен on для log_destination='stderr' и 'csvlog', а также если будут использоваться параметры log_directory и log_filename), после изменения необходима перезагрузка

log_directory - определяет в какой каталог записывать файлы журналов, путь может быть абсолютным или относительным PGDATA (например, log_directory='pg_log'). Необходимо, чтобы logging_collector=on

log_filename - шаблон имени файла журнала, может включать спецификаторы, которые понимает strftime() (например, log_filename='postgresql-%Y-%m-%d_%H%M%S.log'). Необходимо, чтобы logging_collector=on

log_truncate_on_rotation - on-перезаписывать или off-дописывать в конец

log_rotation_age = 1d - создается новый файл для журнала по истечению 1 дня

log_rotation_size = 10MB - создается новый файл для журнала по достижению размера 10 МБ

Один из способов настроить авторотацию:

logging_collector = on

log_filename = 'postgresql_%a.log' #идентификатор %a означает, что в имени файла будет фигурировать день недели

log_truncate_on_rotation = on

Здесь имя будет повторяться через каждые 7 дней, т е файл будет храниться неделю, а затем перезаписываться.

В этом случае размер файла в 10 МБ может быть недостаточно (возможно по необходимости вообще отменить ограничение на размер)

Можно настроить писать журналы в syslog:

syslog_facility = 'LOCAL0'

syslog_ident = 'postgres'

syslog_sequence_numbers = on

syslog_split_messages = on

log_min_duration_statement = -1 - протоколирование медленных запросов (не есть причина проблем, а лишь следствие, т к 1000 запросов по 500 мсек хуже двух запросов по 5 сек)

log_checkpoints = off - писать ли информацию о контрольных точках

log_connections = off - писать ли факт установления подключения

log_disconnections = off - писать ли факт разрыва подключения

log_duration = on - сколько времени выполнялись команды

log_line_prefix = '%m [%p] %q%u@%d ' - формат сообщения об ошибке:

%a - имя приложения

%u - имя пользователя

%d - имя базы данных

%r - удаленный сервер и порт

%h - удаленный сервер

%p - идентификатор процесса

%t - временная метка без мсек

%m - временная метка с мсек

%n - временная метка с мсек (как в Unix)

%i - тег команды

%e - состояние SQL

%c - идентификатор сеанса

%l - номер строки сеанса

%s - временная метка начала сеанса

%v - идентификатор виртуальной транзакции

%x - идентификатор транзакции (0, если отсутствует)

%q - ничего не происходит, непользовательские процессы останавливаются в этой точке

%% - '%'

log_lock_waits - записывать ли сообщение о том, что если блокировка удерживается дольше, чем величина deadlock_timeout

log_statement = 'none' - что протоколировать ('none' - только ошибки, 'ddl' ошибки+DDL команды, 'mod' - ошибки+DDL-команды+DML-команды, 'all' - все команды)

log_replication_commands = off - включить более детальную информацию о репликации (off - выключено по умолчанию, on - включить)

log_temp_files = 4096 - протоколировать временные файлы, размер которых в килобайтах больше или равен заданной величине (-1 - отключить, 0 - протоколировать все временные файлы, 4096 - протоколировать временные файлы, размер которых больше 4 МБ)

log_timezone - задать часовой пояс для записей журнала (используется в распределенных РСУБД)

По мотивам:

https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server

и

https://postgrespro.ru/docs/postgrespro/12/runtime-config-resource

Transparent huge pages рекомендуют отключать в linux

https://m.habr.com/company/southbridge/blog/435558/



Удобный калькулятор, подбирающий базовые параметры по типу нагрузки и железу:

http://pgconfigurator.cybertec.at/